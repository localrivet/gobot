// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: organizations.sql

package db

import (
	"context"
	"database/sql"
)

const addOrganizationMember = `-- name: AddOrganizationMember :one

INSERT INTO organization_members (id, organization_id, user_id, role, joined_at)
VALUES (?1, ?2, ?3, ?4, strftime('%s', 'now'))
RETURNING id, organization_id, user_id, role, joined_at
`

type AddOrganizationMemberParams struct {
	ID             string `json:"id"`
	OrganizationID string `json:"organization_id"`
	UserID         string `json:"user_id"`
	Role           string `json:"role"`
}

// Organization Members
func (q *Queries) AddOrganizationMember(ctx context.Context, arg AddOrganizationMemberParams) (OrganizationMember, error) {
	row := q.db.QueryRowContext(ctx, addOrganizationMember,
		arg.ID,
		arg.OrganizationID,
		arg.UserID,
		arg.Role,
	)
	var i OrganizationMember
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const checkSlugExists = `-- name: CheckSlugExists :one
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END as found
FROM organizations WHERE LOWER(slug) = LOWER(?1)
`

func (q *Queries) CheckSlugExists(ctx context.Context, slug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkSlugExists, slug)
	var found int64
	err := row.Scan(&found)
	return found, err
}

const countOrganizationMembers = `-- name: CountOrganizationMembers :one
SELECT COUNT(*) as count FROM organization_members WHERE organization_id = ?1
`

func (q *Queries) CountOrganizationMembers(ctx context.Context, organizationID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrganizationMembers, organizationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO organizations (id, name, slug, logo_url, owner_id, created_at, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, strftime('%s', 'now'), strftime('%s', 'now'))
RETURNING id, name, slug, logo_url, owner_id, created_at, updated_at
`

type CreateOrganizationParams struct {
	ID      string         `json:"id"`
	Name    string         `json:"name"`
	Slug    string         `json:"slug"`
	LogoUrl sql.NullString `json:"logo_url"`
	OwnerID string         `json:"owner_id"`
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Organization, error) {
	row := q.db.QueryRowContext(ctx, createOrganization,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.LogoUrl,
		arg.OwnerID,
	)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.LogoUrl,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrganizationInvite = `-- name: CreateOrganizationInvite :one

INSERT INTO organization_invites (id, organization_id, email, role, token, invited_by, expires_at, created_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, strftime('%s', 'now'))
RETURNING id, organization_id, email, role, token, invited_by, expires_at, created_at
`

type CreateOrganizationInviteParams struct {
	ID             string `json:"id"`
	OrganizationID string `json:"organization_id"`
	Email          string `json:"email"`
	Role           string `json:"role"`
	Token          string `json:"token"`
	InvitedBy      string `json:"invited_by"`
	ExpiresAt      int64  `json:"expires_at"`
}

// Organization Invites
func (q *Queries) CreateOrganizationInvite(ctx context.Context, arg CreateOrganizationInviteParams) (OrganizationInvite, error) {
	row := q.db.QueryRowContext(ctx, createOrganizationInvite,
		arg.ID,
		arg.OrganizationID,
		arg.Email,
		arg.Role,
		arg.Token,
		arg.InvitedBy,
		arg.ExpiresAt,
	)
	var i OrganizationInvite
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.Token,
		&i.InvitedBy,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredInvites = `-- name: DeleteExpiredInvites :exec
DELETE FROM organization_invites WHERE expires_at <= strftime('%s', 'now')
`

func (q *Queries) DeleteExpiredInvites(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredInvites)
	return err
}

const deleteInvite = `-- name: DeleteInvite :exec
DELETE FROM organization_invites WHERE id = ?1
`

func (q *Queries) DeleteInvite(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteInvite, id)
	return err
}

const deleteInviteByToken = `-- name: DeleteInviteByToken :exec
DELETE FROM organization_invites WHERE token = ?1
`

func (q *Queries) DeleteInviteByToken(ctx context.Context, token string) error {
	_, err := q.db.ExecContext(ctx, deleteInviteByToken, token)
	return err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
DELETE FROM organizations WHERE id = ?1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteOrganization, id)
	return err
}

const getCurrentOrganization = `-- name: GetCurrentOrganization :one
SELECT current_organization_id FROM user_preferences WHERE user_id = ?1 LIMIT 1
`

func (q *Queries) GetCurrentOrganization(ctx context.Context, userID string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getCurrentOrganization, userID)
	var current_organization_id sql.NullString
	err := row.Scan(&current_organization_id)
	return current_organization_id, err
}

const getInviteByEmail = `-- name: GetInviteByEmail :one
SELECT id, organization_id, email, role, token, invited_by, expires_at, created_at FROM organization_invites
WHERE organization_id = ?1 AND LOWER(email) = LOWER(?2)
LIMIT 1
`

type GetInviteByEmailParams struct {
	OrganizationID string `json:"organization_id"`
	Email          string `json:"email"`
}

func (q *Queries) GetInviteByEmail(ctx context.Context, arg GetInviteByEmailParams) (OrganizationInvite, error) {
	row := q.db.QueryRowContext(ctx, getInviteByEmail, arg.OrganizationID, arg.Email)
	var i OrganizationInvite
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.Token,
		&i.InvitedBy,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getInviteByToken = `-- name: GetInviteByToken :one
SELECT oi.id, oi.organization_id, oi.email, oi.role, oi.token, oi.invited_by, oi.expires_at, oi.created_at, o.name as organization_name, o.slug as organization_slug
FROM organization_invites oi
JOIN organizations o ON oi.organization_id = o.id
WHERE oi.token = ?1 AND oi.expires_at > strftime('%s', 'now')
LIMIT 1
`

type GetInviteByTokenRow struct {
	ID               string `json:"id"`
	OrganizationID   string `json:"organization_id"`
	Email            string `json:"email"`
	Role             string `json:"role"`
	Token            string `json:"token"`
	InvitedBy        string `json:"invited_by"`
	ExpiresAt        int64  `json:"expires_at"`
	CreatedAt        int64  `json:"created_at"`
	OrganizationName string `json:"organization_name"`
	OrganizationSlug string `json:"organization_slug"`
}

func (q *Queries) GetInviteByToken(ctx context.Context, token string) (GetInviteByTokenRow, error) {
	row := q.db.QueryRowContext(ctx, getInviteByToken, token)
	var i GetInviteByTokenRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.Email,
		&i.Role,
		&i.Token,
		&i.InvitedBy,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationSlug,
	)
	return i, err
}

const getOrganizationByID = `-- name: GetOrganizationByID :one
SELECT id, name, slug, logo_url, owner_id, created_at, updated_at FROM organizations WHERE id = ?1 LIMIT 1
`

func (q *Queries) GetOrganizationByID(ctx context.Context, id string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationByID, id)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.LogoUrl,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationBySlug = `-- name: GetOrganizationBySlug :one
SELECT id, name, slug, logo_url, owner_id, created_at, updated_at FROM organizations WHERE slug = ?1 LIMIT 1
`

func (q *Queries) GetOrganizationBySlug(ctx context.Context, slug string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationBySlug, slug)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.LogoUrl,
		&i.OwnerID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrganizationMember = `-- name: GetOrganizationMember :one
SELECT om.id, om.organization_id, om.user_id, om.role, om.joined_at, u.email, u.name as user_name, u.avatar_url
FROM organization_members om
JOIN users u ON om.user_id = u.id
WHERE om.organization_id = ?1 AND om.user_id = ?2
LIMIT 1
`

type GetOrganizationMemberParams struct {
	OrganizationID string `json:"organization_id"`
	UserID         string `json:"user_id"`
}

type GetOrganizationMemberRow struct {
	ID             string         `json:"id"`
	OrganizationID string         `json:"organization_id"`
	UserID         string         `json:"user_id"`
	Role           string         `json:"role"`
	JoinedAt       int64          `json:"joined_at"`
	Email          string         `json:"email"`
	UserName       string         `json:"user_name"`
	AvatarUrl      sql.NullString `json:"avatar_url"`
}

func (q *Queries) GetOrganizationMember(ctx context.Context, arg GetOrganizationMemberParams) (GetOrganizationMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getOrganizationMember, arg.OrganizationID, arg.UserID)
	var i GetOrganizationMemberRow
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
		&i.Email,
		&i.UserName,
		&i.AvatarUrl,
	)
	return i, err
}

const listOrganizationInvites = `-- name: ListOrganizationInvites :many
SELECT oi.id, oi.organization_id, oi.email, oi.role, oi.token, oi.invited_by, oi.expires_at, oi.created_at, u.name as inviter_name, u.email as inviter_email
FROM organization_invites oi
JOIN users u ON oi.invited_by = u.id
WHERE oi.organization_id = ?1 AND oi.expires_at > strftime('%s', 'now')
ORDER BY oi.created_at DESC
`

type ListOrganizationInvitesRow struct {
	ID             string `json:"id"`
	OrganizationID string `json:"organization_id"`
	Email          string `json:"email"`
	Role           string `json:"role"`
	Token          string `json:"token"`
	InvitedBy      string `json:"invited_by"`
	ExpiresAt      int64  `json:"expires_at"`
	CreatedAt      int64  `json:"created_at"`
	InviterName    string `json:"inviter_name"`
	InviterEmail   string `json:"inviter_email"`
}

func (q *Queries) ListOrganizationInvites(ctx context.Context, organizationID string) ([]ListOrganizationInvitesRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationInvites, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationInvitesRow
	for rows.Next() {
		var i ListOrganizationInvitesRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.Email,
			&i.Role,
			&i.Token,
			&i.InvitedBy,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.InviterName,
			&i.InviterEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrganizationMembers = `-- name: ListOrganizationMembers :many
SELECT om.id, om.organization_id, om.user_id, om.role, om.joined_at, u.email, u.name as user_name, u.avatar_url
FROM organization_members om
JOIN users u ON om.user_id = u.id
WHERE om.organization_id = ?1
ORDER BY om.joined_at ASC
`

type ListOrganizationMembersRow struct {
	ID             string         `json:"id"`
	OrganizationID string         `json:"organization_id"`
	UserID         string         `json:"user_id"`
	Role           string         `json:"role"`
	JoinedAt       int64          `json:"joined_at"`
	Email          string         `json:"email"`
	UserName       string         `json:"user_name"`
	AvatarUrl      sql.NullString `json:"avatar_url"`
}

func (q *Queries) ListOrganizationMembers(ctx context.Context, organizationID string) ([]ListOrganizationMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrganizationMembers, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrganizationMembersRow
	for rows.Next() {
		var i ListOrganizationMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.Email,
			&i.UserName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrganizations = `-- name: ListUserOrganizations :many
SELECT o.id, o.name, o.slug, o.logo_url, o.owner_id, o.created_at, o.updated_at FROM organizations o
JOIN organization_members om ON o.id = om.organization_id
WHERE om.user_id = ?1
ORDER BY o.created_at DESC
`

func (q *Queries) ListUserOrganizations(ctx context.Context, userID string) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, listUserOrganizations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOrganizationMember = `-- name: RemoveOrganizationMember :exec
DELETE FROM organization_members
WHERE organization_id = ?1 AND user_id = ?2
`

type RemoveOrganizationMemberParams struct {
	OrganizationID string `json:"organization_id"`
	UserID         string `json:"user_id"`
}

func (q *Queries) RemoveOrganizationMember(ctx context.Context, arg RemoveOrganizationMemberParams) error {
	_, err := q.db.ExecContext(ctx, removeOrganizationMember, arg.OrganizationID, arg.UserID)
	return err
}

const setCurrentOrganization = `-- name: SetCurrentOrganization :exec

UPDATE user_preferences
SET current_organization_id = ?1,
    updated_at = strftime('%s', 'now')
WHERE user_id = ?2
`

type SetCurrentOrganizationParams struct {
	OrganizationID sql.NullString `json:"organization_id"`
	UserID         string         `json:"user_id"`
}

// User Preferences (org related)
func (q *Queries) SetCurrentOrganization(ctx context.Context, arg SetCurrentOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, setCurrentOrganization, arg.OrganizationID, arg.UserID)
	return err
}

const updateMemberRole = `-- name: UpdateMemberRole :exec
UPDATE organization_members
SET role = ?1
WHERE organization_id = ?2 AND user_id = ?3
`

type UpdateMemberRoleParams struct {
	Role           string `json:"role"`
	OrganizationID string `json:"organization_id"`
	UserID         string `json:"user_id"`
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateMemberRole, arg.Role, arg.OrganizationID, arg.UserID)
	return err
}

const updateOrganization = `-- name: UpdateOrganization :exec
UPDATE organizations
SET name = COALESCE(?1, name),
    slug = COALESCE(?2, slug),
    logo_url = COALESCE(?3, logo_url),
    updated_at = strftime('%s', 'now')
WHERE id = ?4
`

type UpdateOrganizationParams struct {
	Name    sql.NullString `json:"name"`
	Slug    sql.NullString `json:"slug"`
	LogoUrl sql.NullString `json:"logo_url"`
	ID      string         `json:"id"`
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, updateOrganization,
		arg.Name,
		arg.Slug,
		arg.LogoUrl,
		arg.ID,
	)
	return err
}
