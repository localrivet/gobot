// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: mcp_sessions.sql

package db

import (
	"context"
	"database/sql"
)

const cleanupOldMCPSessions = `-- name: CleanupOldMCPSessions :exec
DELETE FROM mcp_sessions
WHERE updated_at < unixepoch() - 604800
`

// Run periodically to clean up stale sessions (older than 7 days)
func (q *Queries) CleanupOldMCPSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupOldMCPSessions)
	return err
}

const deleteMCPSession = `-- name: DeleteMCPSession :exec
DELETE FROM mcp_sessions WHERE session_id = ?
`

func (q *Queries) DeleteMCPSession(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deleteMCPSession, sessionID)
	return err
}

const getMCPSession = `-- name: GetMCPSession :one

SELECT session_id, user_id, org_id, created_at, updated_at FROM mcp_sessions
WHERE session_id = ?
`

// MCP Session queries for organization selection persistence
func (q *Queries) GetMCPSession(ctx context.Context, sessionID string) (McpSession, error) {
	row := q.db.QueryRowContext(ctx, getMCPSession, sessionID)
	var i McpSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.OrgID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMCPSessionByUser = `-- name: GetMCPSessionByUser :one
SELECT session_id, user_id, org_id, created_at, updated_at FROM mcp_sessions
WHERE user_id = ? AND org_id IS NOT NULL
ORDER BY updated_at DESC
LIMIT 1
`

// Fallback: get most recent org selection for a user (when session ID changes)
func (q *Queries) GetMCPSessionByUser(ctx context.Context, userID string) (McpSession, error) {
	row := q.db.QueryRowContext(ctx, getMCPSessionByUser, userID)
	var i McpSession
	err := row.Scan(
		&i.SessionID,
		&i.UserID,
		&i.OrgID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertMCPSession = `-- name: UpsertMCPSession :exec
INSERT INTO mcp_sessions (session_id, user_id, org_id, updated_at)
VALUES (?, ?, ?, unixepoch())
ON CONFLICT (session_id) DO UPDATE SET
    org_id = excluded.org_id,
    updated_at = unixepoch()
`

type UpsertMCPSessionParams struct {
	SessionID string         `json:"session_id"`
	UserID    string         `json:"user_id"`
	OrgID     sql.NullString `json:"org_id"`
}

// Persist org selection (upsert to handle both new and existing sessions)
func (q *Queries) UpsertMCPSession(ctx context.Context, arg UpsertMCPSessionParams) error {
	_, err := q.db.ExecContext(ctx, upsertMCPSession, arg.SessionID, arg.UserID, arg.OrgID)
	return err
}
